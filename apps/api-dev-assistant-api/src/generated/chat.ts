// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: chat.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type {
  handleServerStreamingCall,
  handleUnaryCall,
  Metadata as Metadata1,
  UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const protobufPackage = "chat";

/** Request to start or continue a conversation */
export interface ChatRequest {
  conversationId: string;
  message: string;
  metadata: { [key: string]: string };
}

export interface ChatRequest_MetadataEntry {
  key: string;
  value: string;
}

/** Streamed chunk of the conversation response */
export interface ChatChunk {
  text?: TextChunk | undefined;
  toolCall?: ToolCall | undefined;
  toolResult?: ToolResult | undefined;
  metadata?: Metadata | undefined;
  error?:
    | ErrorInfo
    | undefined;
  /** Sent when the graph pauses and needs human input (HITL) */
  interrupt?: InterruptChunk | undefined;
  isFinal: boolean;
  sequence: number;
}

/** Text content chunk (streamed incrementally) */
export interface TextChunk {
  content: string;
  role: string;
}

/** Tool call information */
export interface ToolCall {
  toolId: string;
  toolName: string;
  arguments: string;
  status: ToolCall_Status;
}

export enum ToolCall_Status {
  PENDING = 0,
  IN_PROGRESS = 1,
  COMPLETED = 2,
  FAILED = 3,
  UNRECOGNIZED = -1,
}

/** Tool execution result */
export interface ToolResult {
  toolId: string;
  toolName: string;
  result: string;
  success: boolean;
  errorMessage: string;
}

/** HITL interrupt — graph paused awaiting human review of a generated spec */
export interface InterruptChunk {
  /** Opaque ID; pass back in FeedbackRequest.interrupt_id to resume the graph */
  interruptId: string;
  specId: string;
  specTitle: string;
  endpointCount: number;
  message: string;
}

/** Final metadata sent at end of stream */
export interface Metadata {
  conversationId: string;
  messageCount: number;
  hasMarkdown: boolean;
  hasToolCalls: boolean;
  tokenUsage: TokenUsage | undefined;
  timestamp: string;
  model: string;
}

/** Token usage tracking */
export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  estimatedCost: number;
}

/** Error information */
export interface ErrorInfo {
  code: string;
  message: string;
  details: string;
  retryable: boolean;
}

/** Human-in-the-loop feedback after reviewing a generated spec */
export interface FeedbackRequest {
  conversationId: string;
  /** interrupt_id from the InterruptChunk that triggered this review */
  interruptId: string;
  /** "approve" | "refine" | "reject" */
  action: string;
  /** Required when action = "refine"; describes what should change */
  notes: string;
}

export interface FeedbackResponse {
  success: boolean;
  message: string;
}

export interface DeleteRequest {
  conversationId: string;
}

export interface DeleteResponse {
  message: string;
  messagesDeleted: number;
}

/** Start a new conversation — backend generates the conversation ID */
export interface StartConversationRequest {
  /** Optional metadata (e.g., user info, client version) */
  metadata: { [key: string]: string };
}

export interface StartConversationRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface StartConversationResponse {
  conversationId: string;
}

/** Phase 1 clarification response (unary) */
export interface ClarifyResponse {
  /** markdown / mermaid response from the consultant */
  content: string;
  /** true when content contains markdown formatting */
  hasMarkdown: boolean;
  /** true when content contains a mermaid diagram block */
  hasMermaid: boolean;
  conversationId: string;
}

/** Request to transition from clarification → api_design phase */
export interface TransitionRequest {
  conversationId: string;
}

/** Response from phase transition — includes the generated requirements contract */
export interface TransitionResponse {
  conversationId: string;
  /** structured markdown requirements doc */
  clarificationSummary: string;
}

export const CHAT_PACKAGE_NAME = "chat";

function createBaseChatRequest(): ChatRequest {
  return { conversationId: "", message: "", metadata: {} };
}

export const ChatRequest: MessageFns<ChatRequest> = {
  encode(message: ChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      ChatRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ChatRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseChatRequest_MetadataEntry(): ChatRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const ChatRequest_MetadataEntry: MessageFns<ChatRequest_MetadataEntry> = {
  encode(message: ChatRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseChatChunk(): ChatChunk {
  return { isFinal: false, sequence: 0 };
}

export const ChatChunk: MessageFns<ChatChunk> = {
  encode(message: ChatChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      TextChunk.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.toolCall !== undefined) {
      ToolCall.encode(message.toolCall, writer.uint32(18).fork()).join();
    }
    if (message.toolResult !== undefined) {
      ToolResult.encode(message.toolResult, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorInfo.encode(message.error, writer.uint32(42).fork()).join();
    }
    if (message.interrupt !== undefined) {
      InterruptChunk.encode(message.interrupt, writer.uint32(66).fork()).join();
    }
    if (message.isFinal !== false) {
      writer.uint32(48).bool(message.isFinal);
    }
    if (message.sequence !== 0) {
      writer.uint32(56).int32(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = TextChunk.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolCall = ToolCall.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toolResult = ToolResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = ErrorInfo.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.interrupt = InterruptChunk.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sequence = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTextChunk(): TextChunk {
  return { content: "", role: "" };
}

export const TextChunk: MessageFns<TextChunk> = {
  encode(message: TextChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { toolId: "", toolName: "", arguments: "", status: 0 };
}

export const ToolCall: MessageFns<ToolCall> = {
  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolId !== "") {
      writer.uint32(10).string(message.toolId);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.arguments !== "") {
      writer.uint32(26).string(message.arguments);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseToolResult(): ToolResult {
  return { toolId: "", toolName: "", result: "", success: false, errorMessage: "" };
}

export const ToolResult: MessageFns<ToolResult> = {
  encode(message: ToolResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toolId !== "") {
      writer.uint32(10).string(message.toolId);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.result !== "") {
      writer.uint32(26).string(message.result);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toolId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseInterruptChunk(): InterruptChunk {
  return { interruptId: "", specId: "", specTitle: "", endpointCount: 0, message: "" };
}

export const InterruptChunk: MessageFns<InterruptChunk> = {
  encode(message: InterruptChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interruptId !== "") {
      writer.uint32(10).string(message.interruptId);
    }
    if (message.specId !== "") {
      writer.uint32(18).string(message.specId);
    }
    if (message.specTitle !== "") {
      writer.uint32(26).string(message.specTitle);
    }
    if (message.endpointCount !== 0) {
      writer.uint32(32).int32(message.endpointCount);
    }
    if (message.message !== "") {
      writer.uint32(42).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterruptChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.interruptId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.specId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endpointCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return {
    conversationId: "",
    messageCount: 0,
    hasMarkdown: false,
    hasToolCalls: false,
    tokenUsage: undefined,
    timestamp: "",
    model: "",
  };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.messageCount !== 0) {
      writer.uint32(16).int32(message.messageCount);
    }
    if (message.hasMarkdown !== false) {
      writer.uint32(24).bool(message.hasMarkdown);
    }
    if (message.hasToolCalls !== false) {
      writer.uint32(32).bool(message.hasToolCalls);
    }
    if (message.tokenUsage !== undefined) {
      TokenUsage.encode(message.tokenUsage, writer.uint32(42).fork()).join();
    }
    if (message.timestamp !== "") {
      writer.uint32(50).string(message.timestamp);
    }
    if (message.model !== "") {
      writer.uint32(58).string(message.model);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasMarkdown = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasToolCalls = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenUsage = TokenUsage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.model = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTokenUsage(): TokenUsage {
  return { promptTokens: 0, completionTokens: 0, totalTokens: 0, estimatedCost: 0 };
}

export const TokenUsage: MessageFns<TokenUsage> = {
  encode(message: TokenUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.promptTokens !== 0) {
      writer.uint32(8).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(16).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int32(message.totalTokens);
    }
    if (message.estimatedCost !== 0) {
      writer.uint32(33).double(message.estimatedCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.estimatedCost = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseErrorInfo(): ErrorInfo {
  return { code: "", message: "", details: "", retryable: false };
}

export const ErrorInfo: MessageFns<ErrorInfo> = {
  encode(message: ErrorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.retryable !== false) {
      writer.uint32(32).bool(message.retryable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.retryable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFeedbackRequest(): FeedbackRequest {
  return { conversationId: "", interruptId: "", action: "", notes: "" };
}

export const FeedbackRequest: MessageFns<FeedbackRequest> = {
  encode(message: FeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.interruptId !== "") {
      writer.uint32(18).string(message.interruptId);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.notes !== "") {
      writer.uint32(34).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.interruptId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFeedbackResponse(): FeedbackResponse {
  return { success: false, message: "" };
}

export const FeedbackResponse: MessageFns<FeedbackResponse> = {
  encode(message: FeedbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { conversationId: "" };
}

export const DeleteRequest: MessageFns<DeleteRequest> = {
  encode(message: DeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { message: "", messagesDeleted: 0 };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(message: DeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.messagesDeleted !== 0) {
      writer.uint32(16).int32(message.messagesDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messagesDeleted = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStartConversationRequest(): StartConversationRequest {
  return { metadata: {} };
}

export const StartConversationRequest: MessageFns<StartConversationRequest> = {
  encode(message: StartConversationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      StartConversationRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartConversationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = StartConversationRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.metadata[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStartConversationRequest_MetadataEntry(): StartConversationRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const StartConversationRequest_MetadataEntry: MessageFns<StartConversationRequest_MetadataEntry> = {
  encode(message: StartConversationRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartConversationRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartConversationRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStartConversationResponse(): StartConversationResponse {
  return { conversationId: "" };
}

export const StartConversationResponse: MessageFns<StartConversationResponse> = {
  encode(message: StartConversationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartConversationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseClarifyResponse(): ClarifyResponse {
  return { content: "", hasMarkdown: false, hasMermaid: false, conversationId: "" };
}

export const ClarifyResponse: MessageFns<ClarifyResponse> = {
  encode(message: ClarifyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.hasMarkdown !== false) {
      writer.uint32(16).bool(message.hasMarkdown);
    }
    if (message.hasMermaid !== false) {
      writer.uint32(24).bool(message.hasMermaid);
    }
    if (message.conversationId !== "") {
      writer.uint32(34).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClarifyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClarifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasMarkdown = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasMermaid = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTransitionRequest(): TransitionRequest {
  return { conversationId: "" };
}

export const TransitionRequest: MessageFns<TransitionRequest> = {
  encode(message: TransitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseTransitionResponse(): TransitionResponse {
  return { conversationId: "", clarificationSummary: "" };
}

export const TransitionResponse: MessageFns<TransitionResponse> = {
  encode(message: TransitionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== "") {
      writer.uint32(10).string(message.conversationId);
    }
    if (message.clarificationSummary !== "") {
      writer.uint32(18).string(message.clarificationSummary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clarificationSummary = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

/** ChatService provides AI-powered conversational API development assistance */

export interface ChatServiceClient {
  /** Create a new conversation and receive a backend-generated conversation ID */

  startConversation(
    request: StartConversationRequest,
    metadata: Metadata1,
    ...rest: any
  ): Observable<StartConversationResponse>;

  /** Unary RPC for Phase 1 (clarification): conversational requirements gathering */

  clarifyChat(request: ChatRequest, metadata: Metadata1, ...rest: any): Observable<ClarifyResponse>;

  /**
   * Unary RPC to transition from Phase 1 → Phase 2.
   * Server generates a clarification summary and flips phase to 'api_design'.
   */

  transitionToApiPhase(request: TransitionRequest, metadata: Metadata1, ...rest: any): Observable<TransitionResponse>;

  /** Server-side streaming RPC for real-time chat responses */

  streamChat(request: ChatRequest, metadata: Metadata1, ...rest: any): Observable<ChatChunk>;

  /**
   * Resume a graph that was paused for human review.
   * Returns a stream because the resumed graph may produce substantial output
   * (e.g., when the action is "refine" and the agent re-generates the spec).
   */

  sendFeedback(request: FeedbackRequest, metadata: Metadata1, ...rest: any): Observable<ChatChunk>;

  /** Delete a conversation and its history */

  deleteConversation(request: DeleteRequest, metadata: Metadata1, ...rest: any): Observable<DeleteResponse>;
}

/** ChatService provides AI-powered conversational API development assistance */

export interface ChatServiceController {
  /** Create a new conversation and receive a backend-generated conversation ID */

  startConversation(
    request: StartConversationRequest,
    metadata: Metadata1,
    ...rest: any
  ): Promise<StartConversationResponse> | Observable<StartConversationResponse> | StartConversationResponse;

  /** Unary RPC for Phase 1 (clarification): conversational requirements gathering */

  clarifyChat(
    request: ChatRequest,
    metadata: Metadata1,
    ...rest: any
  ): Promise<ClarifyResponse> | Observable<ClarifyResponse> | ClarifyResponse;

  /**
   * Unary RPC to transition from Phase 1 → Phase 2.
   * Server generates a clarification summary and flips phase to 'api_design'.
   */

  transitionToApiPhase(
    request: TransitionRequest,
    metadata: Metadata1,
    ...rest: any
  ): Promise<TransitionResponse> | Observable<TransitionResponse> | TransitionResponse;

  /** Server-side streaming RPC for real-time chat responses */

  streamChat(request: ChatRequest, metadata: Metadata1, ...rest: any): Observable<ChatChunk>;

  /**
   * Resume a graph that was paused for human review.
   * Returns a stream because the resumed graph may produce substantial output
   * (e.g., when the action is "refine" and the agent re-generates the spec).
   */

  sendFeedback(request: FeedbackRequest, metadata: Metadata1, ...rest: any): Observable<ChatChunk>;

  /** Delete a conversation and its history */

  deleteConversation(
    request: DeleteRequest,
    metadata: Metadata1,
    ...rest: any
  ): Promise<DeleteResponse> | Observable<DeleteResponse> | DeleteResponse;
}

export function ChatServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "startConversation",
      "clarifyChat",
      "transitionToApiPhase",
      "streamChat",
      "sendFeedback",
      "deleteConversation",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ChatService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ChatService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CHAT_SERVICE_NAME = "ChatService";

/** ChatService provides AI-powered conversational API development assistance */
export type ChatServiceService = typeof ChatServiceService;
export const ChatServiceService = {
  /** Create a new conversation and receive a backend-generated conversation ID */
  startConversation: {
    path: "/chat.ChatService/StartConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StartConversationRequest): Buffer =>
      Buffer.from(StartConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StartConversationRequest => StartConversationRequest.decode(value),
    responseSerialize: (value: StartConversationResponse): Buffer =>
      Buffer.from(StartConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StartConversationResponse => StartConversationResponse.decode(value),
  },
  /** Unary RPC for Phase 1 (clarification): conversational requirements gathering */
  clarifyChat: {
    path: "/chat.ChatService/ClarifyChat",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChatRequest): Buffer => Buffer.from(ChatRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChatRequest => ChatRequest.decode(value),
    responseSerialize: (value: ClarifyResponse): Buffer => Buffer.from(ClarifyResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ClarifyResponse => ClarifyResponse.decode(value),
  },
  /**
   * Unary RPC to transition from Phase 1 → Phase 2.
   * Server generates a clarification summary and flips phase to 'api_design'.
   */
  transitionToApiPhase: {
    path: "/chat.ChatService/TransitionToApiPhase",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: TransitionRequest): Buffer => Buffer.from(TransitionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): TransitionRequest => TransitionRequest.decode(value),
    responseSerialize: (value: TransitionResponse): Buffer => Buffer.from(TransitionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): TransitionResponse => TransitionResponse.decode(value),
  },
  /** Server-side streaming RPC for real-time chat responses */
  streamChat: {
    path: "/chat.ChatService/StreamChat",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ChatRequest): Buffer => Buffer.from(ChatRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChatRequest => ChatRequest.decode(value),
    responseSerialize: (value: ChatChunk): Buffer => Buffer.from(ChatChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer): ChatChunk => ChatChunk.decode(value),
  },
  /**
   * Resume a graph that was paused for human review.
   * Returns a stream because the resumed graph may produce substantial output
   * (e.g., when the action is "refine" and the agent re-generates the spec).
   */
  sendFeedback: {
    path: "/chat.ChatService/SendFeedback",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: FeedbackRequest): Buffer => Buffer.from(FeedbackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FeedbackRequest => FeedbackRequest.decode(value),
    responseSerialize: (value: ChatChunk): Buffer => Buffer.from(ChatChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer): ChatChunk => ChatChunk.decode(value),
  },
  /** Delete a conversation and its history */
  deleteConversation: {
    path: "/chat.ChatService/DeleteConversation",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRequest): Buffer => Buffer.from(DeleteRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteRequest => DeleteRequest.decode(value),
    responseSerialize: (value: DeleteResponse): Buffer => Buffer.from(DeleteResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteResponse => DeleteResponse.decode(value),
  },
} as const;

export interface ChatServiceServer extends UntypedServiceImplementation {
  /** Create a new conversation and receive a backend-generated conversation ID */
  startConversation: handleUnaryCall<StartConversationRequest, StartConversationResponse>;
  /** Unary RPC for Phase 1 (clarification): conversational requirements gathering */
  clarifyChat: handleUnaryCall<ChatRequest, ClarifyResponse>;
  /**
   * Unary RPC to transition from Phase 1 → Phase 2.
   * Server generates a clarification summary and flips phase to 'api_design'.
   */
  transitionToApiPhase: handleUnaryCall<TransitionRequest, TransitionResponse>;
  /** Server-side streaming RPC for real-time chat responses */
  streamChat: handleServerStreamingCall<ChatRequest, ChatChunk>;
  /**
   * Resume a graph that was paused for human review.
   * Returns a stream because the resumed graph may produce substantial output
   * (e.g., when the action is "refine" and the agent re-generates the spec).
   */
  sendFeedback: handleServerStreamingCall<FeedbackRequest, ChatChunk>;
  /** Delete a conversation and its history */
  deleteConversation: handleUnaryCall<DeleteRequest, DeleteResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
